        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Context class / path.context Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="path.context" data-type="Context">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../path.context.html">path.context</a> &rsaquo; <a href="../path.context/Context.html">Context</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Context</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An instantiable class for manipulating paths. Unlike the top-level
functions, this lets you explicitly select what platform the paths will use.</p>
<pre class="source">
class Context {
 /// Creates a new path context for the given style and current directory.
 ///
 /// If [style] is omitted, it uses the host operating system's path style. If
 /// only [current] is omitted, it defaults ".". If *both* [style] and
 /// [current] are omitted, [current] defaults to the real current working
 /// directory.
 ///
 /// On the browser, [style] defaults to [Style.url] and [current] defaults to
 /// the current URL.
 factory Context({Style style, String current}) {
   if (current == null) {
     if (style == null) {
       current = p.current;
     } else {
       current = ".";
     }
   }

   if (style == null) style = Style.platform;

   return new Context._(style, current);
 }

 Context._(this.style, this.current);

 /// The style of path that this context works with.
 final Style style;

 /// The current directory that relative paths will be relative to.
 final String current;

 /// Gets the path separator for the context's [style]. On Mac and Linux,
 /// this is `/`. On Windows, it's `\`.
 String get separator =&gt; style.separator;

 /// Creates a new path by appending the given path parts to [current].
 /// Equivalent to [join()] with [current] as the first argument. Example:
 ///
 ///     var context = new Context(current: '/root');
 ///     context.absolute('path', 'to', 'foo'); // -&gt; '/root/path/to/foo'
 ///
 /// If [current] isn't absolute, this won't return an absolute path.
 String absolute(String part1, [String part2, String part3, String part4,
             String part5, String part6, String part7]) {
   return join(current, part1, part2, part3, part4, part5, part6, part7);
 }

 /// Gets the part of [path] after the last separator on the context's
 /// platform.
 ///
 ///     context.basename('path/to/foo.dart'); // -&gt; 'foo.dart'
 ///     context.basename('path/to');          // -&gt; 'to'
 ///
 /// Trailing separators are ignored.
 ///
 ///     context.basename('path/to/'); // -&gt; 'to'
 String basename(String path) =&gt; _parse(path).basename;

 /// Gets the part of [path] after the last separator on the context's
 /// platform, and without any trailing file extension.
 ///
 ///     context.basenameWithoutExtension('path/to/foo.dart'); // -&gt; 'foo'
 ///
 /// Trailing separators are ignored.
 ///
 ///     context.basenameWithoutExtension('path/to/foo.dart/'); // -&gt; 'foo'
 String basenameWithoutExtension(String path) =&gt;
   _parse(path).basenameWithoutExtension;

 /// Gets the part of [path] before the last separator.
 ///
 ///     context.dirname('path/to/foo.dart'); // -&gt; 'path/to'
 ///     context.dirname('path/to');          // -&gt; 'path'
 ///
 /// Trailing separators are ignored.
 ///
 ///     context.dirname('path/to/'); // -&gt; 'path'
 String dirname(String path) {
   var parsed = _parse(path);
   parsed.removeTrailingSeparators();
   if (parsed.parts.isEmpty) return parsed.root == null ? '.' : parsed.root;
   if (parsed.parts.length == 1) {
     return parsed.root == null ? '.' : parsed.root;
   }
   parsed.parts.removeLast();
   parsed.separators.removeLast();
   parsed.removeTrailingSeparators();
   return parsed.toString();
 }

 /// Gets the file extension of [path]: the portion of [basename] from the last
 /// `.` to the end (including the `.` itself).
 ///
 ///     context.extension('path/to/foo.dart'); // -&gt; '.dart'
 ///     context.extension('path/to/foo'); // -&gt; ''
 ///     context.extension('path.to/foo'); // -&gt; ''
 ///     context.extension('path/to/foo.dart.js'); // -&gt; '.js'
 ///
 /// If the file name starts with a `.`, then it is not considered an
 /// extension:
 ///
 ///     context.extension('~/.bashrc');    // -&gt; ''
 ///     context.extension('~/.notes.txt'); // -&gt; '.txt'
 String extension(String path) =&gt; _parse(path).extension;

 // TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
 /// Returns the root of [path] if it's absolute, or an empty string if it's
 /// relative.
 ///
 ///     // Unix
 ///     context.rootPrefix('path/to/foo'); // -&gt; ''
 ///     context.rootPrefix('/path/to/foo'); // -&gt; '/'
 ///
 ///     // Windows
 ///     context.rootPrefix(r'path\to\foo'); // -&gt; ''
 ///     context.rootPrefix(r'C:\path\to\foo'); // -&gt; r'C:\'
 ///
 ///     // URL
 ///     context.rootPrefix('path/to/foo'); // -&gt; ''
 ///     context.rootPrefix('http://dartlang.org/path/to/foo');
 ///       // -&gt; 'http://dartlang.org'
 String rootPrefix(String path) {
   var root = _parse(path).root;
   return root == null ? '' : root;
 }

 /// Returns `true` if [path] is an absolute path and `false` if it is a
 /// relative path.
 ///
 /// On POSIX systems, absolute paths start with a `/` (forward slash). On
 /// Windows, an absolute path starts with `\\`, or a drive letter followed by
 /// `:/` or `:\`. For URLs, absolute paths either start with a protocol and
 /// optional hostname (e.g. `http://dartlang.org`, `file://`) or with a `/`.
 ///
 /// URLs that start with `/` are known as "root-relative", since they're
 /// relative to the root of the current URL. Since root-relative paths are
 /// still absolute in every other sense, [isAbsolute] will return true for
 /// them. They can be detected using [isRootRelative].
 bool isAbsolute(String path) =&gt; _parse(path).isAbsolute;

 /// Returns `true` if [path] is a relative path and `false` if it is absolute.
 /// On POSIX systems, absolute paths start with a `/` (forward slash). On
 /// Windows, an absolute path starts with `\\`, or a drive letter followed by
 /// `:/` or `:\`.
 bool isRelative(String path) =&gt; !this.isAbsolute(path);

 /// Returns `true` if [path] is a root-relative path and `false` if it's not.
 ///
 /// URLs that start with `/` are known as "root-relative", since they're
 /// relative to the root of the current URL. Since root-relative paths are
 /// still absolute in every other sense, [isAbsolute] will return true for
 /// them. They can be detected using [isRootRelative].
 ///
 /// No POSIX and Windows paths are root-relative.
 bool isRootRelative(String path) =&gt; _parse(path).isRootRelative;

 /// Joins the given path parts into a single path. Example:
 ///
 ///     context.join('path', 'to', 'foo'); // -&gt; 'path/to/foo'
 ///
 /// If any part ends in a path separator, then a redundant separator will not
 /// be added:
 ///
 ///     context.join('path/', 'to', 'foo'); // -&gt; 'path/to/foo
 ///
 /// If a part is an absolute path, then anything before that will be ignored:
 ///
 ///     context.join('path', '/to', 'foo'); // -&gt; '/to/foo'
 ///
 String join(String part1, [String part2, String part3, String part4,
             String part5, String part6, String part7, String part8]) {
   var parts = [part1, part2, part3, part4, part5, part6, part7, part8];
   _validateArgList("join", parts);
   return joinAll(parts.where((part) =&gt; part != null));
 }

 /// Joins the given path parts into a single path. Example:
 ///
 ///     context.joinAll(['path', 'to', 'foo']); // -&gt; 'path/to/foo'
 ///
 /// If any part ends in a path separator, then a redundant separator will not
 /// be added:
 ///
 ///     context.joinAll(['path/', 'to', 'foo']); // -&gt; 'path/to/foo
 ///
 /// If a part is an absolute path, then anything before that will be ignored:
 ///
 ///     context.joinAll(['path', '/to', 'foo']); // -&gt; '/to/foo'
 ///
 /// For a fixed number of parts, [join] is usually terser.
 String joinAll(Iterable&lt;String&gt; parts) {
   var buffer = new StringBuffer();
   var needsSeparator = false;
   var isAbsoluteAndNotRootRelative = false;

   for (var part in parts.where((part) =&gt; part != '')) {
     if (this.isRootRelative(part) &amp;&amp; isAbsoluteAndNotRootRelative) {
       // If the new part is root-relative, it preserves the previous root but
       // replaces the path after it.
       var parsed = _parse(part);
       parsed.root = this.rootPrefix(buffer.toString());
       if (parsed.root.contains(style.needsSeparatorPattern)) {
         parsed.separators[0] = style.separator;
       }
       buffer.clear();
       buffer.write(parsed.toString());
     } else if (this.isAbsolute(part)) {
       isAbsoluteAndNotRootRelative = !this.isRootRelative(part);
       // An absolute path discards everything before it.
       buffer.clear();
       buffer.write(part);
     } else {
       if (part.length &gt; 0 &amp;&amp; part[0].contains(style.separatorPattern)) {
         // The part starts with a separator, so we don't need to add one.
       } else if (needsSeparator) {
         buffer.write(separator);
       }

       buffer.write(part);
     }

     // Unless this part ends with a separator, we'll need to add one before
     // the next part.
     needsSeparator = part.contains(style.needsSeparatorPattern);
   }

   return buffer.toString();
 }

 // TODO(nweiz): add a UNC example for Windows once issue 7323 is fixed.
 /// Splits [path] into its components using the current platform's
 /// [separator]. Example:
 ///
 ///     context.split('path/to/foo'); // -&gt; ['path', 'to', 'foo']
 ///
 /// The path will *not* be normalized before splitting.
 ///
 ///     context.split('path/../foo'); // -&gt; ['path', '..', 'foo']
 ///
 /// If [path] is absolute, the root directory will be the first element in the
 /// array. Example:
 ///
 ///     // Unix
 ///     context.split('/path/to/foo'); // -&gt; ['/', 'path', 'to', 'foo']
 ///
 ///     // Windows
 ///     context.split(r'C:\path\to\foo'); // -&gt; [r'C:\', 'path', 'to', 'foo']
 List&lt;String&gt; split(String path) {
   var parsed = _parse(path);
   // Filter out empty parts that exist due to multiple separators in a row.
   parsed.parts = parsed.parts.where((part) =&gt; !part.isEmpty)
                              .toList();
   if (parsed.root != null) parsed.parts.insert(0, parsed.root);
   return parsed.parts;
 }

 /// Normalizes [path], simplifying it by handling `..`, and `.`, and
 /// removing redundant path separators whenever possible.
 ///
 ///     context.normalize('path/./to/..//file.text'); // -&gt; 'path/file.txt'
 String normalize(String path) {
   var parsed = _parse(path);
   parsed.normalize();
   return parsed.toString();
 }

 /// Attempts to convert [path] to an equivalent relative path relative to
 /// [root].
 ///
 ///     var context = new Context(current: '/root/path');
 ///     context.relative('/root/path/a/b.dart'); // -&gt; 'a/b.dart'
 ///     context.relative('/root/other.dart'); // -&gt; '../other.dart'
 ///
 /// If the [from] argument is passed, [path] is made relative to that instead.
 ///
 ///     context.relative('/root/path/a/b.dart',
 ///         from: '/root/path'); // -&gt; 'a/b.dart'
 ///     context.relative('/root/other.dart',
 ///         from: '/root/path'); // -&gt; '../other.dart'
 ///
 /// If [path] and/or [from] are relative paths, they are assumed to be
 /// relative to [current].
 ///
 /// Since there is no relative path from one drive letter to another on
 /// Windows, this will return an absolute path in that case.
 ///
 ///     context.relative(r'D:\other', from: r'C:\other'); // -&gt; 'D:\other'
 ///
 /// This will also return an absolute path if an absolute [path] is passed to
 /// a context with a relative path for [current].
 ///
 ///     var context = new Context(r'some/relative/path');
 ///     context.relative(r'/absolute/path'); // -&gt; '/absolute/path'
 ///
 /// If [root] is relative, it may be impossible to determine a path from
 /// [from] to [path]. For example, if [root] and [path] are "." and [from] is
 /// "/", no path can be determined. In this case, a [PathException] will be
 /// thrown.
 String relative(String path, {String from}) {
   from = from == null ? current : this.join(current, from);

   // We can't determine the path from a relative path to an absolute path.
   if (this.isRelative(from) &amp;&amp; this.isAbsolute(path)) {
     return this.normalize(path);
   }

   // If the given path is relative, resolve it relative to the context's
   // current directory.
   if (this.isRelative(path) || this.isRootRelative(path)) {
     path = this.absolute(path);
   }

   // If the path is still relative and `from` is absolute, we're unable to
   // find a path from `from` to `path`.
   if (this.isRelative(path) &amp;&amp; this.isAbsolute(from)) {
     throw new PathException('Unable to find a path to "$path" from "$from".');
   }

   var fromParsed = _parse(from)..normalize();
   var pathParsed = _parse(path)..normalize();

   if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '.') {
     return pathParsed.toString();
   }

   // If the root prefixes don't match (for example, different drive letters
   // on Windows), then there is no relative path, so just return the absolute
   // one. In Windows, drive letters are case-insenstive and we allow
   // calculation of relative paths, even if a path has not been normalized.
   if (fromParsed.root != pathParsed.root &amp;&amp;
       ((fromParsed.root ==  null || pathParsed.root == null) ||
         fromParsed.root.toLowerCase().replaceAll('/', '\\') !=
         pathParsed.root.toLowerCase().replaceAll('/', '\\'))) {
     return pathParsed.toString();
   }

   // Strip off their common prefix.
   while (fromParsed.parts.length &gt; 0 &amp;&amp; pathParsed.parts.length &gt; 0 &amp;&amp;
          fromParsed.parts[0] == pathParsed.parts[0]) {
     fromParsed.parts.removeAt(0);
     fromParsed.separators.removeAt(1);
     pathParsed.parts.removeAt(0);
     pathParsed.separators.removeAt(1);
   }

   // If there are any directories left in the from path, we need to walk up
   // out of them. If a directory left in the from path is '..', it cannot
   // be cancelled by adding a '..'.
   if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '..') {
     throw new PathException('Unable to find a path to "$path" from "$from".');
   }
   pathParsed.parts.insertAll(0,
       new List.filled(fromParsed.parts.length, '..'));
   pathParsed.separators[0] = '';
   pathParsed.separators.insertAll(1,
       new List.filled(fromParsed.parts.length, style.separator));

   // Corner case: the paths completely collapsed.
   if (pathParsed.parts.length == 0) return '.';

   // Corner case: path was '.' and some '..' directories were added in front.
   // Don't add a final '/.' in that case.
   if (pathParsed.parts.length &gt; 1 &amp;&amp; pathParsed.parts.last == '.') {
     pathParsed.parts.removeLast();
     pathParsed.separators..removeLast()..removeLast()..add('');
   }

   // Make it relative.
   pathParsed.root = '';
   pathParsed.removeTrailingSeparators();

   return pathParsed.toString();
 }

 /// Returns `true` if [child] is a path beneath `parent`, and `false`
 /// otherwise.
 ///
 ///     path.isWithin('/root/path', '/root/path/a'); // -&gt; true
 ///     path.isWithin('/root/path', '/root/other'); // -&gt; false
 ///     path.isWithin('/root/path', '/root/path'); // -&gt; false
 bool isWithin(String parent, String child) {
   var relative;
   try {
     relative = this.relative(child, from: parent);
   } on PathException catch (_) {
     // If no relative path from [parent] to [child] is found, [child]
     // definitely isn't a child of [parent].
     return false;
   }

   var parts = this.split(relative);
   return this.isRelative(relative) &amp;&amp; parts.first != '..' &amp;&amp;
       parts.first != '.';
 }

 /// Removes a trailing extension from the last part of [path].
 ///
 ///     context.withoutExtension('path/to/foo.dart'); // -&gt; 'path/to/foo'
 String withoutExtension(String path) {
   var parsed = _parse(path);

   for (var i = parsed.parts.length - 1; i &gt;= 0; i--) {
     if (!parsed.parts[i].isEmpty) {
       parsed.parts[i] = parsed.basenameWithoutExtension;
       break;
     }
   }

   return parsed.toString();
 }

 /// Returns the path represented by [uri].
 ///
 /// For POSIX and Windows styles, [uri] must be a `file:` URI. For the URL
 /// style, this will just convert [uri] to a string.
 ///
 ///     // POSIX
 ///     context.fromUri(Uri.parse('file:///path/to/foo'))
 ///       // -&gt; '/path/to/foo'
 ///
 ///     // Windows
 ///     context.fromUri(Uri.parse('file:///C:/path/to/foo'))
 ///       // -&gt; r'C:\path\to\foo'
 ///
 ///     // URL
 ///     context.fromUri(Uri.parse('http://dartlang.org/path/to/foo'))
 ///       // -&gt; 'http://dartlang.org/path/to/foo'
 String fromUri(Uri uri) =&gt; style.pathFromUri(uri);

 /// Returns the URI that represents [path].
 ///
 /// For POSIX and Windows styles, this will return a `file:` URI. For the URL
 /// style, this will just convert [path] to a [Uri].
 ///
 ///     // POSIX
 ///     context.toUri('/path/to/foo')
 ///       // -&gt; Uri.parse('file:///path/to/foo')
 ///
 ///     // Windows
 ///     context.toUri(r'C:\path\to\foo')
 ///       // -&gt; Uri.parse('file:///C:/path/to/foo')
 ///
 ///     // URL
 ///     context.toUri('http://dartlang.org/path/to/foo')
 ///       // -&gt; Uri.parse('http://dartlang.org/path/to/foo')
 Uri toUri(String path) {
   if (isRelative(path)) {
     return style.relativePathToUri(path);
   } else {
     return style.absolutePathToUri(join(current, path));
   }
 }

 ParsedPath _parse(String path) =&gt; new ParsedPath.parse(path, style);
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
factory <strong>Context</strong>({<a href="../path.style/Style.html">Style</a> style, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> current}) <a class="anchor-link" href="#"
              title="Permalink to Context.Context">#</a></h4>
<div class="doc">
<p>Creates a new path context for the given style and current directory.</p>
<p>If 
<span class="param">style</span> is omitted, it uses the host operating system's path style. If
only 
<span class="param">current</span> is omitted, it defaults ".". If <em>both</em> 
<span class="param">style</span> and

<span class="param">current</span> are omitted, 
<span class="param">current</span> defaults to the real current working
directory.</p>
<p>On the browser, 
<span class="param">style</span> defaults to <code>Style.url</code> and 
<span class="param">current</span> defaults to
the current URL.</p>
<pre class="source">
factory Context({Style style, String current}) {
 if (current == null) {
   if (style == null) {
     current = p.current;
   } else {
     current = ".";
   }
 }

 if (style == null) style = Style.platform;

 return new Context._(style, current);
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="current">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>current</strong> <a class="anchor-link"
            href="#current"
            title="Permalink to Context.current">#</a>
        </h4>
        <div class="doc">
<p>The current directory that relative paths will be relative to.</p>
<pre class="source">
final String current
</pre>
</div>
</div>
<div class="field"><h4 id="separator">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>separator</strong> <a class="anchor-link"
            href="#separator"
            title="Permalink to Context.separator">#</a>
        </h4>
        <div class="doc">
<p>Gets the path separator for the context's <a class="crossref" href="../path.context/Context.html#style">style</a>. On Mac and Linux,
this is <code>/</code>. On Windows, it's <code>\</code>.</p>
<pre class="source">
String get separator =&gt; style.separator;
</pre>
</div>
</div>
<div class="field"><h4 id="style">
<button class="show-code">Code</button>
final <a href="../path.style/Style.html">Style</a>         <strong>style</strong> <a class="anchor-link"
            href="#style"
            title="Permalink to Context.style">#</a>
        </h4>
        <div class="doc">
<p>The style of path that this context works with.</p>
<pre class="source">
final Style style
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="absolute">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>absolute</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part1, [<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part2, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part3, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part4, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part5, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part6, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part7]) <a class="anchor-link" href="#absolute"
              title="Permalink to Context.absolute">#</a></h4>
<div class="doc">
<p>Creates a new path by appending the given path parts to <a class="crossref" href="../path.context/Context.html#current">current</a>.
Equivalent to <code>join()</code> with <a class="crossref" href="../path.context/Context.html#current">current</a> as the first argument. Example:</p>
<pre><code>var context = new Context(current: '/root');
context.absolute('path', 'to', 'foo'); // -&gt; '/root/path/to/foo'
</code></pre>
<p>If <a class="crossref" href="../path.context/Context.html#current">current</a> isn't absolute, this won't return an absolute path.</p>
<pre class="source">
String absolute(String part1, [String part2, String part3, String part4,
           String part5, String part6, String part7]) {
 return join(current, part1, part2, part3, part4, part5, part6, part7);
}
</pre>
</div>
</div>
<div class="method"><h4 id="basename">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>basename</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#basename"
              title="Permalink to Context.basename">#</a></h4>
<div class="doc">
<p>Gets the part of 
<span class="param">path</span> after the last separator on the context's
platform.</p>
<pre><code>context.basename('path/to/foo.dart'); // -&gt; 'foo.dart'
context.basename('path/to');          // -&gt; 'to'
</code></pre>
<p>Trailing separators are ignored.</p>
<pre><code>context.basename('path/to/'); // -&gt; 'to'
</code></pre>
<pre class="source">
String basename(String path) =&gt; _parse(path).basename;
</pre>
</div>
</div>
<div class="method"><h4 id="basenameWithoutExtension">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>basenameWithoutExtension</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#basenameWithoutExtension"
              title="Permalink to Context.basenameWithoutExtension">#</a></h4>
<div class="doc">
<p>Gets the part of 
<span class="param">path</span> after the last separator on the context's
platform, and without any trailing file extension.</p>
<pre><code>context.basenameWithoutExtension('path/to/foo.dart'); // -&gt; 'foo'
</code></pre>
<p>Trailing separators are ignored.</p>
<pre><code>context.basenameWithoutExtension('path/to/foo.dart/'); // -&gt; 'foo'
</code></pre>
<pre class="source">
String basenameWithoutExtension(String path) =&gt;
 _parse(path).basenameWithoutExtension;
</pre>
</div>
</div>
<div class="method"><h4 id="dirname">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>dirname</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#dirname"
              title="Permalink to Context.dirname">#</a></h4>
<div class="doc">
<p>Gets the part of 
<span class="param">path</span> before the last separator.</p>
<pre><code>context.dirname('path/to/foo.dart'); // -&gt; 'path/to'
context.dirname('path/to');          // -&gt; 'path'
</code></pre>
<p>Trailing separators are ignored.</p>
<pre><code>context.dirname('path/to/'); // -&gt; 'path'
</code></pre>
<pre class="source">
String dirname(String path) {
 var parsed = _parse(path);
 parsed.removeTrailingSeparators();
 if (parsed.parts.isEmpty) return parsed.root == null ? '.' : parsed.root;
 if (parsed.parts.length == 1) {
   return parsed.root == null ? '.' : parsed.root;
 }
 parsed.parts.removeLast();
 parsed.separators.removeLast();
 parsed.removeTrailingSeparators();
 return parsed.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="extension">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>extension</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#extension"
              title="Permalink to Context.extension">#</a></h4>
<div class="doc">
<p>Gets the file extension of 
<span class="param">path</span>: the portion of <a class="crossref" href="../path.context/Context.html#basename">basename</a> from the last
<code>.</code> to the end (including the <code>.</code> itself).</p>
<pre><code>context.extension('path/to/foo.dart'); // -&gt; '.dart'
context.extension('path/to/foo'); // -&gt; ''
context.extension('path.to/foo'); // -&gt; ''
context.extension('path/to/foo.dart.js'); // -&gt; '.js'
</code></pre>
<p>If the file name starts with a <code>.</code>, then it is not considered an
extension:</p>
<pre><code>context.extension('~/.bashrc');    // -&gt; ''
context.extension('~/.notes.txt'); // -&gt; '.txt'
</code></pre>
<pre class="source">
String extension(String path) =&gt; _parse(path).extension;
</pre>
</div>
</div>
<div class="method"><h4 id="fromUri">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>fromUri</strong>(<a href="http://api.dartlang.org/dart_core/Uri.html" ref="external">Uri</a> uri) <a class="anchor-link" href="#fromUri"
              title="Permalink to Context.fromUri">#</a></h4>
<div class="doc">
<p>Returns the path represented by 
<span class="param">uri</span>.</p>
<p>For POSIX and Windows styles, 
<span class="param">uri</span> must be a <code>file:</code> URI. For the URL
style, this will just convert 
<span class="param">uri</span> to a string.</p>
<pre><code>// POSIX
context.fromUri(Uri.parse('file:///path/to/foo'))
  // -&gt; '/path/to/foo'

// Windows
context.fromUri(Uri.parse('file:///C:/path/to/foo'))
  // -&gt; r'C:\path\to\foo'

// URL
context.fromUri(Uri.parse('http://dartlang.org/path/to/foo'))
  // -&gt; 'http://dartlang.org/path/to/foo'
</code></pre>
<pre class="source">
String fromUri(Uri uri) =&gt; style.pathFromUri(uri);
</pre>
</div>
</div>
<div class="method"><h4 id="isAbsolute">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isAbsolute</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#isAbsolute"
              title="Permalink to Context.isAbsolute">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">path</span> is an absolute path and <code>false</code> if it is a
relative path.</p>
<p>On POSIX systems, absolute paths start with a <code>/</code> (forward slash). On
Windows, an absolute path starts with <code>\\</code>, or a drive letter followed by
<code>:/</code> or <code>:\</code>. For URLs, absolute paths either start with a protocol and
optional hostname (e.g. <code>http://dartlang.org</code>, <code>file://</code>) or with a <code>/</code>.</p>
<p>URLs that start with <code>/</code> are known as "root-relative", since they're
relative to the root of the current URL. Since root-relative paths are
still absolute in every other sense, <a class="crossref" href="../path.context/Context.html#isAbsolute">isAbsolute</a> will return true for
them. They can be detected using <a class="crossref" href="../path.context/Context.html#isRootRelative">isRootRelative</a>.</p>
<pre class="source">
bool isAbsolute(String path) =&gt; _parse(path).isAbsolute;
</pre>
</div>
</div>
<div class="method"><h4 id="isRelative">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isRelative</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#isRelative"
              title="Permalink to Context.isRelative">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">path</span> is a relative path and <code>false</code> if it is absolute.
On POSIX systems, absolute paths start with a <code>/</code> (forward slash). On
Windows, an absolute path starts with <code>\\</code>, or a drive letter followed by
<code>:/</code> or <code>:\</code>.</p>
<pre class="source">
bool isRelative(String path) =&gt; !this.isAbsolute(path);
</pre>
</div>
</div>
<div class="method"><h4 id="isRootRelative">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isRootRelative</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#isRootRelative"
              title="Permalink to Context.isRootRelative">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">path</span> is a root-relative path and <code>false</code> if it's not.</p>
<p>URLs that start with <code>/</code> are known as "root-relative", since they're
relative to the root of the current URL. Since root-relative paths are
still absolute in every other sense, <a class="crossref" href="../path.context/Context.html#isAbsolute">isAbsolute</a> will return true for
them. They can be detected using <a class="crossref" href="../path.context/Context.html#isRootRelative">isRootRelative</a>.</p>
<p>No POSIX and Windows paths are root-relative.</p>
<pre class="source">
bool isRootRelative(String path) =&gt; _parse(path).isRootRelative;
</pre>
</div>
</div>
<div class="method"><h4 id="isWithin">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> <strong>isWithin</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> parent, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> child) <a class="anchor-link" href="#isWithin"
              title="Permalink to Context.isWithin">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if 
<span class="param">child</span> is a path beneath <code>parent</code>, and <code>false</code>
otherwise.</p>
<pre><code>path.isWithin('/root/path', '/root/path/a'); // -&gt; true
path.isWithin('/root/path', '/root/other'); // -&gt; false
path.isWithin('/root/path', '/root/path'); // -&gt; false
</code></pre>
<pre class="source">
bool isWithin(String parent, String child) {
 var relative;
 try {
   relative = this.relative(child, from: parent);
 } on PathException catch (_) {
   // If no relative path from [parent] to [child] is found, [child]
   // definitely isn't a child of [parent].
   return false;
 }

 var parts = this.split(relative);
 return this.isRelative(relative) &amp;&amp; parts.first != '..' &amp;&amp;
     parts.first != '.';
}
</pre>
</div>
</div>
<div class="method"><h4 id="join">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>join</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part1, [<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part2, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part3, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part4, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part5, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part6, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part7, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> part8]) <a class="anchor-link" href="#join"
              title="Permalink to Context.join">#</a></h4>
<div class="doc">
<p>Joins the given path parts into a single path. Example:</p>
<pre><code>context.join('path', 'to', 'foo'); // -&gt; 'path/to/foo'
</code></pre>
<p>If any part ends in a path separator, then a redundant separator will not
be added:</p>
<pre><code>context.join('path/', 'to', 'foo'); // -&gt; 'path/to/foo
</code></pre>
<p>If a part is an absolute path, then anything before that will be ignored:</p>
<pre><code>context.join('path', '/to', 'foo'); // -&gt; '/to/foo'
</code></pre>
<pre class="source">
String join(String part1, [String part2, String part3, String part4,
           String part5, String part6, String part7, String part8]) {
 var parts = [part1, part2, part3, part4, part5, part6, part7, part8];
 _validateArgList("join", parts);
 return joinAll(parts.where((part) =&gt; part != null));
}
</pre>
</div>
</div>
<div class="method"><h4 id="joinAll">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>joinAll</strong>(<a href="http://api.dartlang.org/dart_core/Iterable.html" ref="external">Iterable</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; parts) <a class="anchor-link" href="#joinAll"
              title="Permalink to Context.joinAll">#</a></h4>
<div class="doc">
<p>Joins the given path parts into a single path. Example:</p>
<pre><code>context.joinAll(['path', 'to', 'foo']); // -&gt; 'path/to/foo'
</code></pre>
<p>If any part ends in a path separator, then a redundant separator will not
be added:</p>
<pre><code>context.joinAll(['path/', 'to', 'foo']); // -&gt; 'path/to/foo
</code></pre>
<p>If a part is an absolute path, then anything before that will be ignored:</p>
<pre><code>context.joinAll(['path', '/to', 'foo']); // -&gt; '/to/foo'
</code></pre>
<p>For a fixed number of parts, <a class="crossref" href="../path.context/Context.html#join">join</a> is usually terser.</p>
<pre class="source">
String joinAll(Iterable&lt;String&gt; parts) {
 var buffer = new StringBuffer();
 var needsSeparator = false;
 var isAbsoluteAndNotRootRelative = false;

 for (var part in parts.where((part) =&gt; part != '')) {
   if (this.isRootRelative(part) &amp;&amp; isAbsoluteAndNotRootRelative) {
     // If the new part is root-relative, it preserves the previous root but
     // replaces the path after it.
     var parsed = _parse(part);
     parsed.root = this.rootPrefix(buffer.toString());
     if (parsed.root.contains(style.needsSeparatorPattern)) {
       parsed.separators[0] = style.separator;
     }
     buffer.clear();
     buffer.write(parsed.toString());
   } else if (this.isAbsolute(part)) {
     isAbsoluteAndNotRootRelative = !this.isRootRelative(part);
     // An absolute path discards everything before it.
     buffer.clear();
     buffer.write(part);
   } else {
     if (part.length &gt; 0 &amp;&amp; part[0].contains(style.separatorPattern)) {
       // The part starts with a separator, so we don't need to add one.
     } else if (needsSeparator) {
       buffer.write(separator);
     }

     buffer.write(part);
   }

   // Unless this part ends with a separator, we'll need to add one before
   // the next part.
   needsSeparator = part.contains(style.needsSeparatorPattern);
 }

 return buffer.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="normalize">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>normalize</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#normalize"
              title="Permalink to Context.normalize">#</a></h4>
<div class="doc">
<p>Normalizes 
<span class="param">path</span>, simplifying it by handling <code>..</code>, and <code>.</code>, and
removing redundant path separators whenever possible.</p>
<pre><code>context.normalize('path/./to/..//file.text'); // -&gt; 'path/file.txt'
</code></pre>
<pre class="source">
String normalize(String path) {
 var parsed = _parse(path);
 parsed.normalize();
 return parsed.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="relative">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>relative</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path, {<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> from}) <a class="anchor-link" href="#relative"
              title="Permalink to Context.relative">#</a></h4>
<div class="doc">
<p>Attempts to convert 
<span class="param">path</span> to an equivalent relative path relative to
<code>root</code>.</p>
<pre><code>var context = new Context(current: '/root/path');
context.relative('/root/path/a/b.dart'); // -&gt; 'a/b.dart'
context.relative('/root/other.dart'); // -&gt; '../other.dart'
</code></pre>
<p>If the 
<span class="param">from</span> argument is passed, 
<span class="param">path</span> is made relative to that instead.</p>
<pre><code>context.relative('/root/path/a/b.dart',
    from: '/root/path'); // -&gt; 'a/b.dart'
context.relative('/root/other.dart',
    from: '/root/path'); // -&gt; '../other.dart'
</code></pre>
<p>If 
<span class="param">path</span> and/or 
<span class="param">from</span> are relative paths, they are assumed to be
relative to <a class="crossref" href="../path.context/Context.html#current">current</a>.</p>
<p>Since there is no relative path from one drive letter to another on
Windows, this will return an absolute path in that case.</p>
<pre><code>context.relative(r'D:\other', from: r'C:\other'); // -&gt; 'D:\other'
</code></pre>
<p>This will also return an absolute path if an absolute 
<span class="param">path</span> is passed to
a context with a relative path for <a class="crossref" href="../path.context/Context.html#current">current</a>.</p>
<pre><code>var context = new Context(r'some/relative/path');
context.relative(r'/absolute/path'); // -&gt; '/absolute/path'
</code></pre>
<p>If <code>root</code> is relative, it may be impossible to determine a path from

<span class="param">from</span> to 
<span class="param">path</span>. For example, if <code>root</code> and 
<span class="param">path</span> are "." and 
<span class="param">from</span> is
"/", no path can be determined. In this case, a <a class="crossref" href="../path.path_exception/PathException.html">PathException</a> will be
thrown.</p>
<pre class="source">
String relative(String path, {String from}) {
 from = from == null ? current : this.join(current, from);

 // We can't determine the path from a relative path to an absolute path.
 if (this.isRelative(from) &amp;&amp; this.isAbsolute(path)) {
   return this.normalize(path);
 }

 // If the given path is relative, resolve it relative to the context's
 // current directory.
 if (this.isRelative(path) || this.isRootRelative(path)) {
   path = this.absolute(path);
 }

 // If the path is still relative and `from` is absolute, we're unable to
 // find a path from `from` to `path`.
 if (this.isRelative(path) &amp;&amp; this.isAbsolute(from)) {
   throw new PathException('Unable to find a path to "$path" from "$from".');
 }

 var fromParsed = _parse(from)..normalize();
 var pathParsed = _parse(path)..normalize();

 if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '.') {
   return pathParsed.toString();
 }

 // If the root prefixes don't match (for example, different drive letters
 // on Windows), then there is no relative path, so just return the absolute
 // one. In Windows, drive letters are case-insenstive and we allow
 // calculation of relative paths, even if a path has not been normalized.
 if (fromParsed.root != pathParsed.root &amp;&amp;
     ((fromParsed.root ==  null || pathParsed.root == null) ||
       fromParsed.root.toLowerCase().replaceAll('/', '\\') !=
       pathParsed.root.toLowerCase().replaceAll('/', '\\'))) {
   return pathParsed.toString();
 }

 // Strip off their common prefix.
 while (fromParsed.parts.length &gt; 0 &amp;&amp; pathParsed.parts.length &gt; 0 &amp;&amp;
        fromParsed.parts[0] == pathParsed.parts[0]) {
   fromParsed.parts.removeAt(0);
   fromParsed.separators.removeAt(1);
   pathParsed.parts.removeAt(0);
   pathParsed.separators.removeAt(1);
 }

 // If there are any directories left in the from path, we need to walk up
 // out of them. If a directory left in the from path is '..', it cannot
 // be cancelled by adding a '..'.
 if (fromParsed.parts.length &gt; 0 &amp;&amp; fromParsed.parts[0] == '..') {
   throw new PathException('Unable to find a path to "$path" from "$from".');
 }
 pathParsed.parts.insertAll(0,
     new List.filled(fromParsed.parts.length, '..'));
 pathParsed.separators[0] = '';
 pathParsed.separators.insertAll(1,
     new List.filled(fromParsed.parts.length, style.separator));

 // Corner case: the paths completely collapsed.
 if (pathParsed.parts.length == 0) return '.';

 // Corner case: path was '.' and some '..' directories were added in front.
 // Don't add a final '/.' in that case.
 if (pathParsed.parts.length &gt; 1 &amp;&amp; pathParsed.parts.last == '.') {
   pathParsed.parts.removeLast();
   pathParsed.separators..removeLast()..removeLast()..add('');
 }

 // Make it relative.
 pathParsed.root = '';
 pathParsed.removeTrailingSeparators();

 return pathParsed.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="rootPrefix">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>rootPrefix</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#rootPrefix"
              title="Permalink to Context.rootPrefix">#</a></h4>
<div class="doc">
<p>Returns the root of 
<span class="param">path</span> if it's absolute, or an empty string if it's
relative.</p>
<pre><code>// Unix
context.rootPrefix('path/to/foo'); // -&gt; ''
context.rootPrefix('/path/to/foo'); // -&gt; '/'

// Windows
context.rootPrefix(r'path\to\foo'); // -&gt; ''
context.rootPrefix(r'C:\path\to\foo'); // -&gt; r'C:\'

// URL
context.rootPrefix('path/to/foo'); // -&gt; ''
context.rootPrefix('http://dartlang.org/path/to/foo');
  // -&gt; 'http://dartlang.org'
</code></pre>
<pre class="source">
String rootPrefix(String path) {
 var root = _parse(path).root;
 return root == null ? '' : root;
}
</pre>
</div>
</div>
<div class="method"><h4 id="split">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>&gt; <strong>split</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#split"
              title="Permalink to Context.split">#</a></h4>
<div class="doc">
<p>Splits 
<span class="param">path</span> into its components using the current platform's
<a class="crossref" href="../path.context/Context.html#separator">separator</a>. Example:</p>
<pre><code>context.split('path/to/foo'); // -&gt; ['path', 'to', 'foo']
</code></pre>
<p>The path will <em>not</em> be normalized before splitting.</p>
<pre><code>context.split('path/../foo'); // -&gt; ['path', '..', 'foo']
</code></pre>
<p>If 
<span class="param">path</span> is absolute, the root directory will be the first element in the
array. Example:</p>
<pre><code>// Unix
context.split('/path/to/foo'); // -&gt; ['/', 'path', 'to', 'foo']

// Windows
context.split(r'C:\path\to\foo'); // -&gt; [r'C:\', 'path', 'to', 'foo']
</code></pre>
<pre class="source">
List&lt;String&gt; split(String path) {
 var parsed = _parse(path);
 // Filter out empty parts that exist due to multiple separators in a row.
 parsed.parts = parsed.parts.where((part) =&gt; !part.isEmpty)
                            .toList();
 if (parsed.root != null) parsed.parts.insert(0, parsed.root);
 return parsed.parts;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toUri">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Uri.html" ref="external">Uri</a> <strong>toUri</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#toUri"
              title="Permalink to Context.toUri">#</a></h4>
<div class="doc">
<p>Returns the URI that represents 
<span class="param">path</span>.</p>
<p>For POSIX and Windows styles, this will return a <code>file:</code> URI. For the URL
style, this will just convert 
<span class="param">path</span> to a <a class="crossref" href="http://api.dartlang.org/dart_core/Uri.html">Uri</a>.</p>
<pre><code>// POSIX
context.toUri('/path/to/foo')
  // -&gt; Uri.parse('file:///path/to/foo')

// Windows
context.toUri(r'C:\path\to\foo')
  // -&gt; Uri.parse('file:///C:/path/to/foo')

// URL
context.toUri('http://dartlang.org/path/to/foo')
  // -&gt; Uri.parse('http://dartlang.org/path/to/foo')
</code></pre>
<pre class="source">
Uri toUri(String path) {
 if (isRelative(path)) {
   return style.relativePathToUri(path);
 } else {
   return style.absolutePathToUri(join(current, path));
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="withoutExtension">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>withoutExtension</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> path) <a class="anchor-link" href="#withoutExtension"
              title="Permalink to Context.withoutExtension">#</a></h4>
<div class="doc">
<p>Removes a trailing extension from the last part of 
<span class="param">path</span>.</p>
<pre><code>context.withoutExtension('path/to/foo.dart'); // -&gt; 'path/to/foo'
</code></pre>
<pre class="source">
String withoutExtension(String path) {
 var parsed = _parse(path);

 for (var i = parsed.parts.length - 1; i &gt;= 0; i--) {
   if (!parsed.parts[i].isEmpty) {
     parsed.parts[i] = parsed.basenameWithoutExtension;
     break;
   }
 }

 return parsed.toString();
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
