        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Chain class / stack_trace.chain Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="stack_trace.chain" data-type="Chain">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../stack_trace.chain.html">stack_trace.chain</a> &rsaquo; <a href="../stack_trace.chain/Chain.html">Chain</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Chain</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A chain of stack traces.</p>
<p>A stack chain is a collection of one or more stack traces that collectively
represent the path from <code>main</code> through nested function calls to a particular
code location, usually where an error was thrown. Multiple stack traces are
necessary when using asynchronous functions, since the program's stack is
reset before each asynchronous callback is run.</p>
<p>Stack chains can be automatically tracked using <a class="crossref" href="../stack_trace.chain/Chain.html#capture">Chain.capture</a>. This sets
up a new <a class="crossref" href="http://api.dartlang.org/dart_async/Zone.html">Zone</a> in which the current stack chain is tracked and can be
accessed using <a class="crossref" href="../stack_trace.chain/Chain.html#current">new Chain.current</a>. Any errors that would be top-leveled in
the zone can be handled, along with their associated chains, with the
<code>onError</code> callback.</p>
<p>For the most part <a class="crossref" href="../stack_trace.chain/Chain.html#capture">Chain.capture</a> will notice when an error is thrown and
associate the correct stack chain with it; the chain can be accessed using
<a class="crossref" href="../stack_trace.chain/Chain.html#forTrace">new Chain.forTrace</a>. However, there are some cases where exceptions won't
be automatically detected: any <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> constructor,
<a class="crossref" href="http://api.dartlang.org/dart_async/Completer.html#completeError">Completer.completeError</a>, <code>Stream.addError</code>, and libraries that use these.
For these, all you need to do is wrap the Future or Stream in a call to
<a class="crossref" href="../stack_trace.chain/Chain.html#track">Chain.track</a> and the errors will be tracked correctly.</p>
<pre class="source">
class Chain implements StackTrace {
 /// The line used in the string representation of stack chains to represent
 /// the gap between traces.
 static const _GAP = '===== asynchronous gap ===========================\n';

 /// The stack traces that make up this chain.
 ///
 /// Like the frames in a stack trace, the traces are ordered from most local
 /// to least local. The first one is the trace where the actual exception was
 /// raised, the second one is where that callback was scheduled, and so on.
 final List&lt;Trace&gt; traces;

 /// The [StackZoneSpecification] for the current zone.
 static StackZoneSpecification get _currentSpec =&gt;
   Zone.current[#stack_trace.stack_zone.spec];

 /// Runs [callback] in a [Zone] in which the current stack chain is tracked
 /// and automatically associated with (most) errors.
 ///
 /// If [onError] is passed, any error in the zone that would otherwise go
 /// unhandled is passed to it, along with the [Chain] associated with that
 /// error. Note that if [callback] produces multiple unhandled errors,
 /// [onError] may be called more than once. If [onError] isn't passed, the
 /// parent Zone's `unhandledErrorHandler` will be called with the error and
 /// its chain.
 ///
 /// For the most part an error thrown in the zone will have the correct stack
 /// chain associated with it. However, there are some cases where exceptions
 /// won't be automatically detected: any [Future] constructor,
 /// [Completer.completeError], [Stream.addError], and libraries that use
 /// these. For these, all you need to do is wrap the Future or Stream in a
 /// call to [Chain.track] and the errors will be tracked correctly.
 ///
 /// Note that even if [onError] isn't passed, this zone will still be an error
 /// zone. This means that any errors that would cross the zone boundary are
 /// considered unhandled.
 ///
 /// If [callback] returns a value, it will be returned by [capture] as well.
 ///
 /// Currently, capturing stack chains doesn't work when using dart2js due to
 /// issues [15171] and [15105]. Stack chains reported on dart2js will contain
 /// only one trace.
 ///
 /// [15171]: https://code.google.com/p/dart/issues/detail?id=15171
 /// [15105]: https://code.google.com/p/dart/issues/detail?id=15105
 static capture(callback(), {ChainHandler onError}) {
   var spec = new StackZoneSpecification(onError);
   return runZoned(callback, zoneSpecification: spec.toSpec(), zoneValues: {
     #stack_trace.stack_zone.spec: spec
   });
 }

 /// Ensures that any errors emitted by [futureOrStream] have the correct stack
 /// chain information associated with them.
 ///
 /// For the most part an error thrown within a [capture] zone will have the
 /// correct stack chain automatically associated with it. However, there are
 /// some cases where exceptions won't be automatically detected: any [Future]
 /// constructor, [Completer.completeError], [Stream.addError], and libraries
 /// that use these.
 ///
 /// This returns a [Future] or [Stream] that will emit the same values and
 /// errors as [futureOrStream]. The only exception is that if [futureOrStream]
 /// emits an error without a stack trace, one will be added in the return
 /// value.
 ///
 /// If this is called outside of a [capture] zone, it just returns
 /// [futureOrStream] as-is.
 ///
 /// As the name suggests, [futureOrStream] may be either a [Future] or a
 /// [Stream].
 static track(futureOrStream) {
   if (_currentSpec == null) return futureOrStream;
   if (futureOrStream is Future) {
     return _currentSpec.trackFuture(futureOrStream, 1);
   } else {
     return _currentSpec.trackStream(futureOrStream, 1);
   }
 }

 /// Returns the current stack chain.
 ///
 /// By default, the first frame of the first trace will be the line where
 /// [Chain.current] is called. If [level] is passed, the first trace will
 /// start that many frames up instead.
 ///
 /// If this is called outside of a [capture] zone, it just returns a
 /// single-trace chain.
 factory Chain.current([int level=0]) {
   if (_currentSpec != null) return _currentSpec.currentChain(level + 1);
   return new Chain([new Trace.current(level + 1)]);
 }

 /// Returns the stack chain associated with [trace].
 ///
 /// The first stack trace in the returned chain will always be [trace]
 /// (converted to a [Trace] if necessary). If there is no chain associated
 /// with [trace] or if this is called outside of a [capture] zone, this just
 /// returns a single-trace chain containing [trace].
 ///
 /// If [trace] is already a [Chain], it will be returned as-is.
 factory Chain.forTrace(StackTrace trace) {
   if (trace is Chain) return trace;
   if (_currentSpec == null) return new Chain([new Trace.from(trace)]);
   return _currentSpec.chainFor(trace);
 }

 /// Parses a string representation of a stack chain.
 ///
 /// Specifically, this parses the output of [Chain.toString].
 factory Chain.parse(String chain) =&gt;
   new Chain(chain.split(_GAP).map((trace) =&gt; new Trace.parseFriendly(trace)));

 /// Returns a new [Chain] comprised of [traces].
 Chain(Iterable&lt;Trace&gt; traces)
     : traces = new UnmodifiableListView&lt;Trace&gt;(traces.toList());

 /// Returns a terser version of [this].
 ///
 /// This calls [Trace.terse] on every trace in [traces], and discards any
 /// trace that contain only internal frames.
 Chain get terse {
   return new Chain(traces.map((trace) =&gt; trace.terse).where((trace) {
     // Ignore traces that contain only internal processing.
     return trace.frames.length &gt; 1;
   }));
 }

 /// Converts [this] to a [Trace].
 ///
 /// The trace version of a chain is just the concatenation of all the traces
 /// in the chain.
 Trace toTrace() =&gt; new Trace(flatten(traces.map((trace) =&gt; trace.frames)));

 String toString() =&gt; traces.join(_GAP);
}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="http://api.dartlang.org/dart_core/StackTrace.html" ref="external">StackTrace</a></span></p>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="capture">
<button class="show-code">Code</button>
dynamic <strong>capture</strong>(callback(), {<a href="../stack_trace.chain/ChainHandler.html">ChainHandler</a> onError}) <a class="anchor-link" href="#capture"
              title="Permalink to Chain.capture">#</a></h4>
<div class="doc">
<p>Runs 
<span class="param">callback</span> in a <a class="crossref" href="http://api.dartlang.org/dart_async/Zone.html">Zone</a> in which the current stack chain is tracked
and automatically associated with (most) errors.</p>
<p>If 
<span class="param">onError</span> is passed, any error in the zone that would otherwise go
unhandled is passed to it, along with the <a class="crossref" href="../stack_trace.chain/Chain.html">Chain</a> associated with that
error. Note that if 
<span class="param">callback</span> produces multiple unhandled errors,

<span class="param">onError</span> may be called more than once. If 
<span class="param">onError</span> isn't passed, the
parent Zone's <code>unhandledErrorHandler</code> will be called with the error and
its chain.</p>
<p>For the most part an error thrown in the zone will have the correct stack
chain associated with it. However, there are some cases where exceptions
won't be automatically detected: any <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> constructor,
<a class="crossref" href="http://api.dartlang.org/dart_async/Completer.html#completeError">Completer.completeError</a>, <code>Stream.addError</code>, and libraries that use
these. For these, all you need to do is wrap the Future or Stream in a
call to <a class="crossref" href="../stack_trace.chain/Chain.html#track">Chain.track</a> and the errors will be tracked correctly.</p>
<p>Note that even if 
<span class="param">onError</span> isn't passed, this zone will still be an error
zone. This means that any errors that would cross the zone boundary are
considered unhandled.</p>
<p>If 
<span class="param">callback</span> returns a value, it will be returned by <a class="crossref" href="../stack_trace.chain/Chain.html#capture">capture</a> as well.</p>
<p>Currently, capturing stack chains doesn't work when using dart2js due to
issues <code>15171</code> and <code>15105</code>. Stack chains reported on dart2js will contain
only one trace.</p>
<pre class="source">
static capture(callback(), {ChainHandler onError}) {
 var spec = new StackZoneSpecification(onError);
 return runZoned(callback, zoneSpecification: spec.toSpec(), zoneValues: {
   #stack_trace.stack_zone.spec: spec
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="track">
<button class="show-code">Code</button>
dynamic <strong>track</strong>(futureOrStream) <a class="anchor-link" href="#track"
              title="Permalink to Chain.track">#</a></h4>
<div class="doc">
<p>Ensures that any errors emitted by 
<span class="param">futureOrStream</span> have the correct stack
chain information associated with them.</p>
<p>For the most part an error thrown within a <a class="crossref" href="../stack_trace.chain/Chain.html#capture">capture</a> zone will have the
correct stack chain automatically associated with it. However, there are
some cases where exceptions won't be automatically detected: any <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a>
constructor, <a class="crossref" href="http://api.dartlang.org/dart_async/Completer.html#completeError">Completer.completeError</a>, <code>Stream.addError</code>, and libraries
that use these.</p>
<p>This returns a <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> or <a class="crossref" href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> that will emit the same values and
errors as 
<span class="param">futureOrStream</span>. The only exception is that if 
<span class="param">futureOrStream</span>
emits an error without a stack trace, one will be added in the return
value.</p>
<p>If this is called outside of a <a class="crossref" href="../stack_trace.chain/Chain.html#capture">capture</a> zone, it just returns

<span class="param">futureOrStream</span> as-is.</p>
<p>As the name suggests, 
<span class="param">futureOrStream</span> may be either a <a class="crossref" href="http://api.dartlang.org/dart_async/Future.html">Future</a> or a
<a class="crossref" href="http://api.dartlang.org/dart_async/Stream.html">Stream</a>.</p>
<pre class="source">
static track(futureOrStream) {
 if (_currentSpec == null) return futureOrStream;
 if (futureOrStream is Future) {
   return _currentSpec.trackFuture(futureOrStream, 1);
 } else {
   return _currentSpec.trackStream(futureOrStream, 1);
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Chain</strong>(<a href="http://api.dartlang.org/dart_core/Iterable.html" ref="external">Iterable</a>&lt;<a href="../trace/Trace.html">Trace</a>&gt; traces) <a class="anchor-link" href="#"
              title="Permalink to Chain.Chain">#</a></h4>
<div class="doc">
<p>Returns a new <a class="crossref" href="../stack_trace.chain/Chain.html">Chain</a> comprised of 
<span class="param">traces</span>.</p>
<pre class="source">
Chain(Iterable&lt;Trace&gt; traces)
   : traces = new UnmodifiableListView&lt;Trace&gt;(traces.toList());
</pre>
</div>
</div>
<div class="method"><h4 id="current">
<button class="show-code">Code</button>
factory <strong>Chain.current</strong>([<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> level = 0]) <a class="anchor-link" href="#current"
              title="Permalink to Chain.Chain.current">#</a></h4>
<div class="doc">
<p>Returns the current stack chain.</p>
<p>By default, the first frame of the first trace will be the line where
<a class="crossref" href="../stack_trace.chain/Chain.html#current">Chain.current</a> is called. If 
<span class="param">level</span> is passed, the first trace will
start that many frames up instead.</p>
<p>If this is called outside of a <a class="crossref" href="../stack_trace.chain/Chain.html#capture">capture</a> zone, it just returns a
single-trace chain.</p>
<pre class="source">
factory Chain.current([int level=0]) {
 if (_currentSpec != null) return _currentSpec.currentChain(level + 1);
 return new Chain([new Trace.current(level + 1)]);
}
</pre>
</div>
</div>
<div class="method"><h4 id="forTrace">
<button class="show-code">Code</button>
factory <strong>Chain.forTrace</strong>(<a href="http://api.dartlang.org/dart_core/StackTrace.html" ref="external">StackTrace</a> trace) <a class="anchor-link" href="#forTrace"
              title="Permalink to Chain.Chain.forTrace">#</a></h4>
<div class="doc">
<p>Returns the stack chain associated with 
<span class="param">trace</span>.</p>
<p>The first stack trace in the returned chain will always be 
<span class="param">trace</span>
(converted to a <a class="crossref" href="../trace/Trace.html">Trace</a> if necessary). If there is no chain associated
with 
<span class="param">trace</span> or if this is called outside of a <a class="crossref" href="../stack_trace.chain/Chain.html#capture">capture</a> zone, this just
returns a single-trace chain containing 
<span class="param">trace</span>.</p>
<p>If 
<span class="param">trace</span> is already a <a class="crossref" href="../stack_trace.chain/Chain.html">Chain</a>, it will be returned as-is.</p>
<pre class="source">
factory Chain.forTrace(StackTrace trace) {
 if (trace is Chain) return trace;
 if (_currentSpec == null) return new Chain([new Trace.from(trace)]);
 return _currentSpec.chainFor(trace);
}
</pre>
</div>
</div>
<div class="method"><h4 id="parse">
<button class="show-code">Code</button>
factory <strong>Chain.parse</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> chain) <a class="anchor-link" href="#parse"
              title="Permalink to Chain.Chain.parse">#</a></h4>
<div class="doc">
<p>Parses a string representation of a stack chain.</p>
<p>Specifically, this parses the output of <a class="crossref" href="../stack_trace.chain/Chain.html#toString">Chain.toString</a>.</p>
<pre class="source">
factory Chain.parse(String chain) =&gt;
 new Chain(chain.split(_GAP).map((trace) =&gt; new Trace.parseFriendly(trace)));
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="terse">
<button class="show-code">Code</button>
final <a href="../stack_trace.chain/Chain.html">Chain</a>         <strong>terse</strong> <a class="anchor-link"
            href="#terse"
            title="Permalink to Chain.terse">#</a>
        </h4>
        <div class="doc">
<p>Returns a terser version of <code>this</code>.</p>
<p>This calls <a class="crossref" href="../trace/Trace.html#terse">Trace.terse</a> on every trace in <a class="crossref" href="../stack_trace.chain/Chain.html#traces">traces</a>, and discards any
trace that contain only internal frames.</p>
<pre class="source">
Chain get terse {
 return new Chain(traces.map((trace) =&gt; trace.terse).where((trace) {
   // Ignore traces that contain only internal processing.
   return trace.frames.length &gt; 1;
 }));
}
</pre>
</div>
</div>
<div class="field"><h4 id="traces">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../trace/Trace.html">Trace</a>&gt;         <strong>traces</strong> <a class="anchor-link"
            href="#traces"
            title="Permalink to Chain.traces">#</a>
        </h4>
        <div class="doc">
<p>The stack traces that make up this chain.</p>
<p>Like the frames in a stack trace, the traces are ordered from most local
to least local. The first one is the trace where the actual exception was
raised, the second one is where that callback was scheduled, and so on.</p>
<pre class="source">
final List&lt;Trace&gt; traces
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to Chain.toString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns a <a class="crossref" href="http://api.dartlang.org/dart_core/String.html">String</a> representation of the stack trace.</p>
<p>The string represents the full stack trace starting from
the point where a throw ocurred to the top of the current call sequence.</p>
<p>The exact format of the string representation is not final.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/StackTrace.html" ref="external">StackTrace</a> </div></div>
<pre class="source">
String toString() =&gt; traces.join(_GAP);
</pre>
</div>
</div>
<div class="method"><h4 id="toTrace">
<button class="show-code">Code</button>
<a href="../trace/Trace.html">Trace</a> <strong>toTrace</strong>() <a class="anchor-link" href="#toTrace"
              title="Permalink to Chain.toTrace">#</a></h4>
<div class="doc">
<p>Converts <code>this</code> to a <a class="crossref" href="../trace/Trace.html">Trace</a>.</p>
<p>The trace version of a chain is just the concatenation of all the traces
in the chain.</p>
<pre class="source">
Trace toTrace() =&gt; new Trace(flatten(traces.map((trace) =&gt; trace.frames)));
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
