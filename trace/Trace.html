        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>Trace class / trace Library / HOP Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="trace" data-type="Trace">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">HOP Documentation</a>
         &rsaquo; <a href="../trace.html">trace</a> &rsaquo; <a href="../trace/Trace.html">Trace</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>Trace</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>A stack trace, comprised of a list of stack frames.</p>
<pre class="source">
class Trace implements StackTrace {
 /// The stack frames that comprise this stack trace.
 final List&lt;Frame&gt; frames;

 /// Returns a human-readable representation of [stackTrace]. If [terse] is
 /// set, this folds together multiple stack frames from the Dart core
 /// libraries, so that only the core library method directly called from user
 /// code is visible (see [Trace.terse]).
 static String format(StackTrace stackTrace, {bool terse: true}) {
   var trace = new Trace.from(stackTrace);
   if (terse) trace = trace.terse;
   return trace.toString();
 }

 /// Returns the current stack trace.
 ///
 /// By default, the first frame of this trace will be the line where
 /// [Trace.current] is called. If [level] is passed, the trace will start that
 /// many frames up instead.
 factory Trace.current([int level=0]) {
   if (level &lt; 0) {
     throw new ArgumentError("Argument [level] must be greater than or equal "
         "to 0.");
   }

   try {
     throw '';
   } catch (_, nativeTrace) {
     var trace = new Trace.from(nativeTrace);
     return new LazyTrace(() =&gt; new Trace(trace.frames.skip(level + 1)));
   }
 }

 /// Returns a new stack trace containing the same data as [trace].
 ///
 /// If [trace] is a native [StackTrace], its data will be parsed out; if it's
 /// a [Trace], it will be returned as-is.
 factory Trace.from(StackTrace trace) {
   if (trace is Trace) return trace;
   return new LazyTrace(() =&gt; new Trace.parse(trace.toString()));
 }

 /// Parses a string representation of a stack trace.
 ///
 /// [trace] should be formatted in the same way as a Dart VM or browser stack
 /// trace.
 factory Trace.parse(String trace) {
   if (trace.isEmpty) return new Trace(&lt;Frame&gt;[]);
   if (trace.startsWith("Error\n")) return new Trace.parseV8(trace);
   if (trace.contains(_firefoxTrace)) return new Trace.parseFirefox(trace);
   if (trace.contains(_friendlyTrace)) return new Trace.parseFriendly(trace);

   // Default to parsing the stack trace as a VM trace. This is also hit on IE
   // and Safari, where the stack trace is just an empty string (issue 11257).
   return new Trace.parseVM(trace);
 }

 /// Parses a string representation of a Dart VM stack trace.
 Trace.parseVM(String trace)
     : this(trace.trim().split("\n").map((line) =&gt; new Frame.parseVM(line)));

 /// Parses a string representation of a Chrome/V8 stack trace.
 Trace.parseV8(String trace)
     : this(trace.split("\n").skip(1).map((line) =&gt; new Frame.parseV8(line)));

 /// Parses a string representation of a Firefox stack trace.
 Trace.parseFirefox(String trace)
     : this(trace.trim().split("\n")
         .map((line) =&gt; new Frame.parseFirefox(line)));

 /// Parses this package's a string representation of a stack trace.
 Trace.parseFriendly(String trace)
     : this(trace.trim().split("\n")
         .map((line) =&gt; new Frame.parseFriendly(line)));

 /// Returns a new [Trace] comprised of [frames].
 Trace(Iterable&lt;Frame&gt; frames)
     : frames = new UnmodifiableListView&lt;Frame&gt;(frames.toList());

 /// Returns a VM-style [StackTrace] object.
 ///
 /// The return value's [toString] method will always return a string
 /// representation in the Dart VM's stack trace format, regardless of what
 /// platform is being used.
 StackTrace get vmTrace =&gt; new VMTrace(frames);

 /// Returns a terser version of [this].
 ///
 /// This is accomplished by folding together multiple stack frames from the
 /// core library, as in [foldFrames]. Remaining core library frames have their
 /// libraries, "-patch" suffixes, and line numbers removed.
 Trace get terse {
   return new Trace(foldFrames((frame) =&gt; frame.isCore).frames.map((frame) {
     if (!frame.isCore) return frame;
     var library = frame.library.replaceAll(_terseRegExp, '');
     return new Frame(Uri.parse(library), null, null, frame.member);
   }));
 }

 /// Returns a new [Trace] based on [this] where multiple stack frames matching
 /// [predicate] are folded together. This means that whenever there are
 /// multiple frames in a row that match [predicate], only the last one is
 /// kept.
 ///
 /// This is useful for limiting the amount of library code that appears in a
 /// stack trace by only showing user code and code that's called by user code.
 Trace foldFrames(bool predicate(frame)) {
   var newFrames = &lt;Frame&gt;[];
   for (var frame in frames.reversed) {
     if (!predicate(frame)) {
       newFrames.add(frame);
     } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
       newFrames.add(new Frame(
           frame.uri, frame.line, frame.column, frame.member));
     }
   }

   return new Trace(newFrames.reversed);
 }

 /// Returns a human-readable string representation of [this].
 String toString() {
   // Figure out the longest path so we know how much to pad.
   var longest = frames.map((frame) =&gt; frame.location.length)
       .fold(0, math.max);

   // Print out the stack trace nicely formatted.
   return frames.map((frame) {
     return '${padRight(frame.location, longest)}  ${frame.member}\n';
   }).join();
 }
}
</pre>
</div>
<h3>Subclasses</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../lazy_trace/LazyTrace.html">LazyTrace</a></span></p>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../dart_core/StackTrace.html">StackTrace</a></span></p>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="format">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a> <strong>format</strong>(<a href="http://api.dartlang.org/dart_core/StackTrace.html">StackTrace</a> stackTrace, {<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> terse: true}) <a class="anchor-link" href="#format"
              title="Permalink to Trace.format">#</a></h4>
<div class="doc">
<p>Returns a human-readable representation of 
<span class="param">stackTrace</span>. If 
<span class="param">terse</span> is
set, this folds together multiple stack frames from the Dart core
libraries, so that only the core library method directly called from user
code is visible (see <a class="crossref" href="../trace/Trace.html#terse">Trace.terse</a>).</p>
<pre class="source">
static String format(StackTrace stackTrace, {bool terse: true}) {
 var trace = new Trace.from(stackTrace);
 if (terse) trace = trace.terse;
 return trace.toString();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>Trace</strong>(<a href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a>&lt;<a href="../frame/Frame.html">Frame</a>&gt; frames) <a class="anchor-link" href="#"
              title="Permalink to Trace.Trace">#</a></h4>
<div class="doc">
<p>Returns a new <a class="crossref" href="../trace/Trace.html">Trace</a> comprised of 
<span class="param">frames</span>.</p>
<pre class="source">
Trace(Iterable&lt;Frame&gt; frames)
   : frames = new UnmodifiableListView&lt;Frame&gt;(frames.toList());
</pre>
</div>
</div>
<div class="method"><h4 id="current">
<button class="show-code">Code</button>
factory <strong>Trace.current</strong>([<a href="http://api.dartlang.org/dart_core/int.html">int</a> level = 0]) <a class="anchor-link" href="#current"
              title="Permalink to Trace.Trace.current">#</a></h4>
<div class="doc">
<p>Returns the current stack trace.</p>
<p>By default, the first frame of this trace will be the line where
<a class="crossref" href="../trace/Trace.html#current">Trace.current</a> is called. If 
<span class="param">level</span> is passed, the trace will start that
many frames up instead.</p>
<pre class="source">
factory Trace.current([int level=0]) {
 if (level &lt; 0) {
   throw new ArgumentError("Argument [level] must be greater than or equal "
       "to 0.");
 }

 try {
   throw '';
 } catch (_, nativeTrace) {
   var trace = new Trace.from(nativeTrace);
   return new LazyTrace(() =&gt; new Trace(trace.frames.skip(level + 1)));
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="from">
<button class="show-code">Code</button>
factory <strong>Trace.from</strong>(<a href="http://api.dartlang.org/dart_core/StackTrace.html">StackTrace</a> trace) <a class="anchor-link" href="#from"
              title="Permalink to Trace.Trace.from">#</a></h4>
<div class="doc">
<p>Returns a new stack trace containing the same data as 
<span class="param">trace</span>.</p>
<p>If 
<span class="param">trace</span> is a native <a class="crossref" href="../dart_core/StackTrace.html">StackTrace</a>, its data will be parsed out; if it's
a <a class="crossref" href="../trace/Trace.html">Trace</a>, it will be returned as-is.</p>
<pre class="source">
factory Trace.from(StackTrace trace) {
 if (trace is Trace) return trace;
 return new LazyTrace(() =&gt; new Trace.parse(trace.toString()));
}
</pre>
</div>
</div>
<div class="method"><h4 id="parse">
<button class="show-code">Code</button>
factory <strong>Trace.parse</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> trace) <a class="anchor-link" href="#parse"
              title="Permalink to Trace.Trace.parse">#</a></h4>
<div class="doc">
<p>Parses a string representation of a stack trace.</p>
<p>
<span class="param">trace</span> should be formatted in the same way as a Dart VM or browser stack
trace.</p>
<pre class="source">
factory Trace.parse(String trace) {
 if (trace.isEmpty) return new Trace(&lt;Frame&gt;[]);
 if (trace.startsWith("Error\n")) return new Trace.parseV8(trace);
 if (trace.contains(_firefoxTrace)) return new Trace.parseFirefox(trace);
 if (trace.contains(_friendlyTrace)) return new Trace.parseFriendly(trace);

 // Default to parsing the stack trace as a VM trace. This is also hit on IE
 // and Safari, where the stack trace is just an empty string (issue 11257).
 return new Trace.parseVM(trace);
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseFirefox">
<button class="show-code">Code</button>
new <strong>Trace.parseFirefox</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> trace) <a class="anchor-link" href="#parseFirefox"
              title="Permalink to Trace.Trace.parseFirefox">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Firefox stack trace.</p>
<pre class="source">
Trace.parseFirefox(String trace)
   : this(trace.trim().split("\n")
       .map((line) =&gt; new Frame.parseFirefox(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseFriendly">
<button class="show-code">Code</button>
new <strong>Trace.parseFriendly</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> trace) <a class="anchor-link" href="#parseFriendly"
              title="Permalink to Trace.Trace.parseFriendly">#</a></h4>
<div class="doc">
<p>Parses this package's a string representation of a stack trace.</p>
<pre class="source">
Trace.parseFriendly(String trace)
   : this(trace.trim().split("\n")
       .map((line) =&gt; new Frame.parseFriendly(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseV8">
<button class="show-code">Code</button>
new <strong>Trace.parseV8</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> trace) <a class="anchor-link" href="#parseV8"
              title="Permalink to Trace.Trace.parseV8">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Chrome/V8 stack trace.</p>
<pre class="source">
Trace.parseV8(String trace)
   : this(trace.split("\n").skip(1).map((line) =&gt; new Frame.parseV8(line)));
</pre>
</div>
</div>
<div class="method"><h4 id="parseVM">
<button class="show-code">Code</button>
new <strong>Trace.parseVM</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> trace) <a class="anchor-link" href="#parseVM"
              title="Permalink to Trace.Trace.parseVM">#</a></h4>
<div class="doc">
<p>Parses a string representation of a Dart VM stack trace.</p>
<pre class="source">
Trace.parseVM(String trace)
   : this(trace.trim().split("\n").map((line) =&gt; new Frame.parseVM(line)));
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="frames">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../frame/Frame.html">Frame</a>&gt;         <strong>frames</strong> <a class="anchor-link"
            href="#frames"
            title="Permalink to Trace.frames">#</a>
        </h4>
        <div class="doc">
<p>The stack frames that comprise this stack trace.</p>
<pre class="source">
final List&lt;Frame&gt; frames
</pre>
</div>
</div>
<div class="field"><h4 id="terse">
<button class="show-code">Code</button>
final <a href="../trace/Trace.html">Trace</a>         <strong>terse</strong> <a class="anchor-link"
            href="#terse"
            title="Permalink to Trace.terse">#</a>
        </h4>
        <div class="doc">
<p>Returns a terser version of <code>this</code>.</p>
<p>This is accomplished by folding together multiple stack frames from the
core library, as in <a class="crossref" href="../trace/Trace.html#foldFrames">foldFrames</a>. Remaining core library frames have their
libraries, "-patch" suffixes, and line numbers removed.</p>
<pre class="source">
Trace get terse {
 return new Trace(foldFrames((frame) =&gt; frame.isCore).frames.map((frame) {
   if (!frame.isCore) return frame;
   var library = frame.library.replaceAll(_terseRegExp, '');
   return new Frame(Uri.parse(library), null, null, frame.member);
 }));
}
</pre>
</div>
</div>
<div class="field"><h4 id="vmTrace">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/StackTrace.html">StackTrace</a>         <strong>vmTrace</strong> <a class="anchor-link"
            href="#vmTrace"
            title="Permalink to Trace.vmTrace">#</a>
        </h4>
        <div class="doc">
<p>Returns a VM-style <a class="crossref" href="../dart_core/StackTrace.html">StackTrace</a> object.</p>
<p>The return value's <a class="crossref" href="../trace/Trace.html#toString">toString</a> method will always return a string
representation in the Dart VM's stack trace format, regardless of what
platform is being used.</p>
<pre class="source">
StackTrace get vmTrace =&gt; new VMTrace(frames);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="foldFrames">
<button class="show-code">Code</button>
<a href="../trace/Trace.html">Trace</a> <strong>foldFrames</strong>(<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> predicate(frame)) <a class="anchor-link" href="#foldFrames"
              title="Permalink to Trace.foldFrames">#</a></h4>
<div class="doc">
<p>Returns a new <a class="crossref" href="../trace/Trace.html">Trace</a> based on <code>this</code> where multiple stack frames matching

<span class="param">predicate</span> are folded together. This means that whenever there are
multiple frames in a row that match 
<span class="param">predicate</span>, only the last one is
kept.</p>
<p>This is useful for limiting the amount of library code that appears in a
stack trace by only showing user code and code that's called by user code.</p>
<pre class="source">
Trace foldFrames(bool predicate(frame)) {
 var newFrames = &lt;Frame&gt;[];
 for (var frame in frames.reversed) {
   if (!predicate(frame)) {
     newFrames.add(frame);
   } else if (newFrames.isEmpty || !predicate(newFrames.last)) {
     newFrames.add(new Frame(
         frame.uri, frame.line, frame.column, frame.member));
   }
 }

 return new Trace(newFrames.reversed);
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a> <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to Trace.toString">#</a></h4>
<div class="doc">
<p>Returns a human-readable string representation of <code>this</code>.</p>
<pre class="source">
String toString() {
 // Figure out the longest path so we know how much to pad.
 var longest = frames.map((frame) =&gt; frame.location.length)
     .fold(0, math.max);

 // Print out the stack trace nicely formatted.
 return frames.map((frame) {
   return '${padRight(frame.location, longest)}  ${frame.member}\n';
 }).join();
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
