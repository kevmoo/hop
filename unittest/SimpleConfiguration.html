        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>SimpleConfiguration class / unittest Library / Hop Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="unittest" data-type="SimpleConfiguration">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Hop Documentation</a>
         &rsaquo; <a href="../unittest.html">unittest</a> &rsaquo; <a href="../unittest/SimpleConfiguration.html">SimpleConfiguration</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>SimpleConfiguration</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Hooks to configure the unittest library for different platforms. This class
implements the API in a platform-independent way. Tests that want to take
advantage of the platform can create a subclass and override methods from
this class.</p>
<pre class="source">
class SimpleConfiguration extends Configuration {
 // The VM won't shut down if a receive port is open. Use this to make sure
 // we correctly wait for asynchronous tests.
 ReceivePort _receivePort;

 /**
  * Subclasses can override this with something useful for diagnostics.
  * Particularly useful in cases where we have parent/child configurations
  * such as layout tests.
  */
 String get name =&gt; 'Configuration';

 bool get autoStart =&gt; true;

 /**
  * If true (the default), throw an exception at the end if any tests failed.
  */
 bool throwOnTestFailures = true;

 /**
  * If true (the default), then tests will stop after the first failed
  * [expect]. If false, failed [expect]s will not cause the test
  * to stop (other exceptions will still terminate the test).
  */
 bool stopTestOnExpectFailure = true;

 // If stopTestOnExpectFailure is false, we need to capture failures, which
 // we do with this List.
 final _testLogBuffer = &lt;Pair&lt;String, StackTrace&gt;&gt;[];

 /// How long a [TestCase] can run before it is considered an error.
 /// A [timeout] value of [:null:] means that the limit is infinite.
 Duration timeout = const Duration(minutes: 2);

 /**
  * The constructor sets up a failure handler for [expect] that redirects
  * [expect] failures to [onExpectFailure].
  */
 SimpleConfiguration() : super.blank() {
   configureExpectFailureHandler(new _ExpectFailureHandler(this));
 }

 void onInit() {
   // For Dart internal tests, we don't want stack frame filtering.
   // We turn it off here in the default config, but by default turn
   // it back on in the vm and html configs.
   filterStacks = false;
   _receivePort = new ReceivePort();
   _postMessage('unittest-suite-wait-for-done');
 }

 /**
  * Called when each test starts. Useful to show intermediate progress on
  * a test suite. Derived classes should call this first before their own
  * override code.
  */
 void onTestStart(TestCase testCase) {
   assert(testCase != null);
   _testLogBuffer.clear();
 }

 /**
  * Called when each test is first completed. Useful to show intermediate
  * progress on a test suite. Derived classes should call this first
  * before their own override code.
  */
 void onTestResult(TestCase testCase) {
   assert(testCase != null);
   if (!stopTestOnExpectFailure &amp;&amp; _testLogBuffer.length &gt; 0) {
     // Write the message/stack pairs up to the last pairs.
     var reason = new StringBuffer();
     for (var reasonAndTrace in
            _testLogBuffer.take(_testLogBuffer.length - 1)) {
       reason.write(reasonAndTrace.first);
       reason.write('\n');
       reason.write(reasonAndTrace.last);
       reason.write('\n');
     }
     var lastReasonAndTrace = _testLogBuffer.last;
     // Write the last message.
     reason.write(lastReasonAndTrace.first);
     if (testCase.result == PASS) {
       testCase._result = FAIL;
       testCase._message = reason.toString();
       // Use the last stack as the overall failure stack.
       testCase._stackTrace = lastReasonAndTrace.last;
     } else {
       // Add the last stack to the message; we have a further stack
       // caused by some other failure.
       reason.write(lastReasonAndTrace.last);
       reason.write('\n');
       // Add the existing reason to the end of the expect log to
       // create the final message.
       testCase._message = '${reason.toString()}\n${testCase._message}';
     }
   }
 }

 void onTestResultChanged(TestCase testCase) {
   assert(testCase != null);
 }

 /**
  * Handles the logging of messages by a test case. The default in
  * this base configuration is to call print();
  */
 void onLogMessage(TestCase testCase, String message) {
   print(message);
 }

 /**
  * Handles failures from expect(). The default in
  * this base configuration is to throw an exception;
  */
 void onExpectFailure(String reason) {
   if (stopTestOnExpectFailure) {
     throw new TestFailure(reason);
   } else {
     try {
       throw '';
     } catch (_, stack) {
       var trace = _getTrace(stack);
       if (trace == null) trace = stack;
       _testLogBuffer.add(new Pair&lt;String, StackTrace&gt;(reason, trace));
     }
   }
 }

 /**
  * Format a test result.
  */
 String formatResult(TestCase testCase) {
   var result = new StringBuffer();
   result.write(testCase.result.toUpperCase());
   result.write(": ");
   result.write(testCase.description);
   result.write("\n");

   if (testCase.message != '') {
     result.write(indent(testCase.message));
     result.write("\n");
   }

   if (testCase.stackTrace != null) {
     result.write(indent(testCase.stackTrace.toString()));
     result.write("\n");
   }
   return result.toString();
 }

 /**
  * Called with the result of all test cases. The default implementation prints
  * the result summary using the built-in [print] command. Browser tests
  * commonly override this to reformat the output.
  *
  * When [uncaughtError] is not null, it contains an error that occured outside
  * of tests (e.g. setting up the test).
  */
 void onSummary(int passed, int failed, int errors, List&lt;TestCase&gt; results,
     String uncaughtError) {
   // Print each test's result.
   for (final t in results) {
     print(formatResult(t).trim());
   }

   // Show the summary.
   print('');

   if (passed == 0 &amp;&amp; failed == 0 &amp;&amp; errors == 0 &amp;&amp; uncaughtError == null) {
     print('No tests found.');
     // This is considered a failure too.
   } else if (failed == 0 &amp;&amp; errors == 0 &amp;&amp; uncaughtError == null) {
     print('All $passed tests passed.');
   } else {
     if (uncaughtError != null) {
       print('Top-level uncaught error: $uncaughtError');
     }
     print('$passed PASSED, $failed FAILED, $errors ERRORS');
   }
 }

 void onDone(bool success) {
   if (success) {
     _postMessage('unittest-suite-success');
     _receivePort.close();
   } else {
     _receivePort.close();
     if (throwOnTestFailures) {
       throw new Exception('Some tests failed.');
     }
   }
 }

 void _postMessage(String message) {
   // In dart2js browser tests, the JavaScript-based test controller
   // intercepts calls to print and listens for "secret" messages.
   print(message);
 }
}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../unittest/Configuration.html">Configuration</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>SimpleConfiguration</strong></span></p>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="">
<button class="show-code">Code</button>
new <strong>SimpleConfiguration</strong>() <a class="anchor-link" href="#"
              title="Permalink to SimpleConfiguration.SimpleConfiguration">#</a></h4>
<div class="doc">
<p>The constructor sets up a failure handler for <a class="crossref" href="../matcher.html#expect">expect</a> that redirects
<a class="crossref" href="../matcher.html#expect">expect</a> failures to <a class="crossref" href="../unittest/SimpleConfiguration.html#onExpectFailure">onExpectFailure</a>.</p>
<pre class="source">
SimpleConfiguration() : super.blank() {
 configureExpectFailureHandler(new _ExpectFailureHandler(this));
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="autoStart">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>autoStart</strong> <a class="anchor-link"
            href="#autoStart"
            title="Permalink to SimpleConfiguration.autoStart">#</a>
        </h4>
        <div class="doc">
<div class="inherited">
<p>If <code>true</code>, tests are started automatically. Otherwise <a class="crossref" href="../unittest.html#runTests">runTests</a>
must be called explicitly after tests are set up.</p>
<div class="docs-inherited-from">docs inherited from <a href="../unittest/Configuration.html">Configuration</a> </div></div>
<pre class="source">
bool get autoStart =&gt; true;
</pre>
</div>
</div>
<div class="field"><h4 id="name">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a>         <strong>name</strong> <a class="anchor-link"
            href="#name"
            title="Permalink to SimpleConfiguration.name">#</a>
        </h4>
        <div class="doc">
<p>Subclasses can override this with something useful for diagnostics.
Particularly useful in cases where we have parent/child configurations
such as layout tests.</p>
<pre class="source">
String get name =&gt; 'Configuration';
</pre>
</div>
</div>
<div class="field"><h4 id="stopTestOnExpectFailure">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>stopTestOnExpectFailure</strong> <a class="anchor-link"
            href="#stopTestOnExpectFailure"
            title="Permalink to SimpleConfiguration.stopTestOnExpectFailure">#</a>
        </h4>
        <div class="doc">
<p>If true (the default), then tests will stop after the first failed
<a class="crossref" href="../matcher.html#expect">expect</a>. If false, failed <a class="crossref" href="../matcher.html#expect">expect</a>s will not cause the test
to stop (other exceptions will still terminate the test).</p>
<pre class="source">
bool stopTestOnExpectFailure = true
</pre>
</div>
</div>
<div class="field"><h4 id="throwOnTestFailures">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a>         <strong>throwOnTestFailures</strong> <a class="anchor-link"
            href="#throwOnTestFailures"
            title="Permalink to SimpleConfiguration.throwOnTestFailures">#</a>
        </h4>
        <div class="doc">
<p>If true (the default), throw an exception at the end if any tests failed.</p>
<pre class="source">
bool throwOnTestFailures = true
</pre>
</div>
</div>
<div class="field"><h4 id="timeout">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Duration.html" ref="external">Duration</a>         <strong>timeout</strong> <a class="anchor-link"
            href="#timeout"
            title="Permalink to SimpleConfiguration.timeout">#</a>
        </h4>
        <div class="doc">
<p>How long a <a class="crossref" href="../unittest/TestCase.html">TestCase</a> can run before it is considered an error.
A <a class="crossref" href="../unittest/SimpleConfiguration.html#timeout">timeout</a> value of <code>null</code> means that the limit is infinite.</p>
<pre class="source">
Duration timeout = const Duration(minutes: 2)
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="formatResult">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> <strong>formatResult</strong>(<a href="../unittest/TestCase.html">TestCase</a> testCase) <a class="anchor-link" href="#formatResult"
              title="Permalink to SimpleConfiguration.formatResult">#</a></h4>
<div class="doc">
<p>Format a test result.</p>
<pre class="source">
String formatResult(TestCase testCase) {
 var result = new StringBuffer();
 result.write(testCase.result.toUpperCase());
 result.write(": ");
 result.write(testCase.description);
 result.write("\n");

 if (testCase.message != '') {
   result.write(indent(testCase.message));
   result.write("\n");
 }

 if (testCase.stackTrace != null) {
   result.write(indent(testCase.stackTrace.toString()));
   result.write("\n");
 }
 return result.toString();
}
</pre>
</div>
</div>
<div class="method"><h4 id="onDone">
<button class="show-code">Code</button>
void <strong>onDone</strong>(<a href="http://api.dartlang.org/dart_core/bool.html" ref="external">bool</a> success) <a class="anchor-link" href="#onDone"
              title="Permalink to SimpleConfiguration.onDone">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Called when the unittest framework is done running. 
<span class="param">success</span> indicates
whether all tests passed successfully.</p>
<div class="docs-inherited-from">docs inherited from <a href="../unittest/Configuration.html">Configuration</a> </div></div>
<pre class="source">
void onDone(bool success) {
 if (success) {
   _postMessage('unittest-suite-success');
   _receivePort.close();
 } else {
   _receivePort.close();
   if (throwOnTestFailures) {
     throw new Exception('Some tests failed.');
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="onExpectFailure">
<button class="show-code">Code</button>
void <strong>onExpectFailure</strong>(<a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> reason) <a class="anchor-link" href="#onExpectFailure"
              title="Permalink to SimpleConfiguration.onExpectFailure">#</a></h4>
<div class="doc">
<p>Handles failures from expect(). The default in
this base configuration is to throw an exception;</p>
<pre class="source">
void onExpectFailure(String reason) {
 if (stopTestOnExpectFailure) {
   throw new TestFailure(reason);
 } else {
   try {
     throw '';
   } catch (_, stack) {
     var trace = _getTrace(stack);
     if (trace == null) trace = stack;
     _testLogBuffer.add(new Pair&lt;String, StackTrace&gt;(reason, trace));
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="onInit">
<button class="show-code">Code</button>
void <strong>onInit</strong>() <a class="anchor-link" href="#onInit"
              title="Permalink to SimpleConfiguration.onInit">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Called as soon as the unittest framework becomes initialized. This is done
even before tests are added to the test framework. It might be used to
determine/debug errors that occur before the test harness starts executing.
It is also used to tell the vm or browser that tests are going to be run
asynchronously and that the process should wait until they are done.</p>
<div class="docs-inherited-from">docs inherited from <a href="../unittest/Configuration.html">Configuration</a> </div></div>
<pre class="source">
void onInit() {
 // For Dart internal tests, we don't want stack frame filtering.
 // We turn it off here in the default config, but by default turn
 // it back on in the vm and html configs.
 filterStacks = false;
 _receivePort = new ReceivePort();
 _postMessage('unittest-suite-wait-for-done');
}
</pre>
</div>
</div>
<div class="method"><h4 id="onLogMessage">
<button class="show-code">Code</button>
void <strong>onLogMessage</strong>(<a href="../unittest/TestCase.html">TestCase</a> testCase, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> message) <a class="anchor-link" href="#onLogMessage"
              title="Permalink to SimpleConfiguration.onLogMessage">#</a></h4>
<div class="doc">
<p>Handles the logging of messages by a test case. The default in
this base configuration is to call print();</p>
<pre class="source">
void onLogMessage(TestCase testCase, String message) {
 print(message);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="onStart">
<button class="show-code">Code</button>
void <strong>onStart</strong>() <a class="anchor-link" href="#onStart"
              title="Permalink to SimpleConfiguration.onStart">#</a></h4>
<div class="inherited-from">inherited from <a href="../unittest/Configuration.html">Configuration</a> </div><div class="doc">
<p>Called as soon as the unittest framework starts running. </p>
<pre class="source">
void onStart() {}
</pre>
</div>
</div>
<div class="method"><h4 id="onSummary">
<button class="show-code">Code</button>
void <strong>onSummary</strong>(<a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> passed, <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> failed, <a href="http://api.dartlang.org/dart_core/int.html" ref="external">int</a> errors, <a href="http://api.dartlang.org/dart_core/List.html" ref="external">List</a>&lt;<a href="../unittest/TestCase.html">TestCase</a>&gt; results, <a href="http://api.dartlang.org/dart_core/String.html" ref="external">String</a> uncaughtError) <a class="anchor-link" href="#onSummary"
              title="Permalink to SimpleConfiguration.onSummary">#</a></h4>
<div class="doc">
<p>Called with the result of all test cases. The default implementation prints
the result summary using the built-in <a class="crossref" href="http://api.dartlang.org/dart.core.html#print">print</a> command. Browser tests
commonly override this to reformat the output.</p>
<p>When 
<span class="param">uncaughtError</span> is not null, it contains an error that occured outside
of tests (e.g. setting up the test).</p>
<pre class="source">
void onSummary(int passed, int failed, int errors, List&lt;TestCase&gt; results,
   String uncaughtError) {
 // Print each test's result.
 for (final t in results) {
   print(formatResult(t).trim());
 }

 // Show the summary.
 print('');

 if (passed == 0 &amp;&amp; failed == 0 &amp;&amp; errors == 0 &amp;&amp; uncaughtError == null) {
   print('No tests found.');
   // This is considered a failure too.
 } else if (failed == 0 &amp;&amp; errors == 0 &amp;&amp; uncaughtError == null) {
   print('All $passed tests passed.');
 } else {
   if (uncaughtError != null) {
     print('Top-level uncaught error: $uncaughtError');
   }
   print('$passed PASSED, $failed FAILED, $errors ERRORS');
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="onTestResult">
<button class="show-code">Code</button>
void <strong>onTestResult</strong>(<a href="../unittest/TestCase.html">TestCase</a> testCase) <a class="anchor-link" href="#onTestResult"
              title="Permalink to SimpleConfiguration.onTestResult">#</a></h4>
<div class="doc">
<p>Called when each test is first completed. Useful to show intermediate
progress on a test suite. Derived classes should call this first
before their own override code.</p>
<pre class="source">
void onTestResult(TestCase testCase) {
 assert(testCase != null);
 if (!stopTestOnExpectFailure &amp;&amp; _testLogBuffer.length &gt; 0) {
   // Write the message/stack pairs up to the last pairs.
   var reason = new StringBuffer();
   for (var reasonAndTrace in
          _testLogBuffer.take(_testLogBuffer.length - 1)) {
     reason.write(reasonAndTrace.first);
     reason.write('\n');
     reason.write(reasonAndTrace.last);
     reason.write('\n');
   }
   var lastReasonAndTrace = _testLogBuffer.last;
   // Write the last message.
   reason.write(lastReasonAndTrace.first);
   if (testCase.result == PASS) {
     testCase._result = FAIL;
     testCase._message = reason.toString();
     // Use the last stack as the overall failure stack.
     testCase._stackTrace = lastReasonAndTrace.last;
   } else {
     // Add the last stack to the message; we have a further stack
     // caused by some other failure.
     reason.write(lastReasonAndTrace.last);
     reason.write('\n');
     // Add the existing reason to the end of the expect log to
     // create the final message.
     testCase._message = '${reason.toString()}\n${testCase._message}';
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="onTestResultChanged">
<button class="show-code">Code</button>
void <strong>onTestResultChanged</strong>(<a href="../unittest/TestCase.html">TestCase</a> testCase) <a class="anchor-link" href="#onTestResultChanged"
              title="Permalink to SimpleConfiguration.onTestResultChanged">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Called when an already completed test changes state. For example: a test
that was marked as passing may later be marked as being in error because
it still had callbacks being invoked.</p>
<div class="docs-inherited-from">docs inherited from <a href="../unittest/Configuration.html">Configuration</a> </div></div>
<pre class="source">
void onTestResultChanged(TestCase testCase) {
 assert(testCase != null);
}
</pre>
</div>
</div>
<div class="method"><h4 id="onTestStart">
<button class="show-code">Code</button>
void <strong>onTestStart</strong>(<a href="../unittest/TestCase.html">TestCase</a> testCase) <a class="anchor-link" href="#onTestStart"
              title="Permalink to SimpleConfiguration.onTestStart">#</a></h4>
<div class="doc">
<p>Called when each test starts. Useful to show intermediate progress on
a test suite. Derived classes should call this first before their own
override code.</p>
<pre class="source">
void onTestStart(TestCase testCase) {
 assert(testCase != null);
 _testLogBuffer.clear();
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
